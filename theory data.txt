lesson one introduction
------------------------------------------------------------------------------------
program > steps to perform task /set of instruction

software > program along with documentation

s/w = program + documentation

s/w component = program + document + operating procedure

s/w crises = overrun development cost + exceed development time + quality not achived

s/w engineering = systematic application of engineering principle and methods to design , development , 		  testing and maintainance of s/w products.
-------------------------------------------------------------------------------------
ðŸŒ¾characteristics of s/w =
>developed through s/w process
>no physical wear and tear
>custom built in feature
>intangible / cannot be touch

ðŸŒ¾major problem in s/w development
>inadequate req gathering 
>lack of communication between stackholder
>poor project managment 
>lack of risk mitigation
>wrong technology selection
>insufficent time and money
>lack of skill set 
>less failure rate over time

ðŸŒ¾s/w quality attribute
>correctness
>usablity
>reliablity
>efficiency
>maintanibility
>portable
>scalability
>security

ðŸŒ¾s/w process :set of releted activities lead to production of s/w
>feasability study
>requirement analysis and specification(srs)
>designing(sdd)
>coding
>testing
>implementation
>mantainalibity

ðŸŒ¾s/w development life cycle : procedure follow during development of s/w product in well defined and managed way

---------------------------------------------------------------------------------------

ðŸ¶ waterfall model
>inspired by manufacturing and construction process
>each step relies on a previous one
>simplest >linear >sequntial model
>one way cannot be go return
>used for small and medium sized project
>well defined and crystal clear requirment are required
>classical model 

steps:
1.	feasibility study
2.	req analysis
3.	design
4.	coding
5.	testing
6.	mainaince

---------------------------------------------------------------------------------------

ðŸ¶ prototype model
>iterative approach
>refine through customer feedback
>repetative till satisfaction
>twotype a) evoluionary b)thrwoaway
>scope for accomodate new requireents

steps:
1.	req gathring
------------------
2.	quick design
3.	build prototype
4.	cstomer evalution
5.	refine requirements
-----repet---------
6.	design
7.	implement
8.	test
9.	maintain

--------------------------------------------------------------------------------------

ðŸ¶ spiral model == risk factor introduce

phase 1: objective determination
phase 2: identify and resolve risk
phase 3: development and test
pahse 4: plan next iteration till satisfaction

>provide early and frequent customer feedback 
>resolve all possible risks
>alllow incermaental release and testing
>not for small project
> risk analyse need experties

---------------------------------------------------------------------------------------

ðŸ¶incermental model

>development of initial implementation -> expose to user feedback -> evolve through several version
>make working s/w at early phase
>easier to test and debug during small iterations
>agile development
>continous improvement
>begin with basic version minimum functionality
>user feedback to make improvements


-----------------------------------------------------------------------------------------
ðŸ± V-Model == verification + validation in parallel
Phase 1: Requirement Analysis
Phase 2: System Design
Phase 3: Architecture Design
Phase 4: Module Design
Phase 5: Coding
Phase 6: Unit Testing
Phase 7: Integration Testing
Phase 8: System Testing
Phase 9: Acceptance Testing

>testing starts from beginning (parallel to development)
>strong discipline and documentation
>suitable for small to medium-size projects
>no overlap in phases â€“ rigid structure
>not flexible for changing requirements
>bugs found early due to planned testing
--------------------------------------------------------------------------------------
ðŸ° Agile Model == fast delivery + continuous feedback
Phase 1: Gather minimal requirements (user stories)
Phase 2: Plan iteration (sprint planning)
Phase 3: Design, Develop, Test within sprint
Phase 4: Deliver working product (increment)
Phase 5: Review & get feedback
Phase 6: Improve in next sprint (loop to Phase 2)

>customer involved in every step
>highly flexible for changes
>short iterations (1â€“4 weeks)
>better team collaboration
>early working software delivery
>requires active client participation
>not ideal for critical systems (banking, aviation, etc.)
--------------------------------------------------------------------------------------
ðŸŒ¾verification : 

>Checks whether the software meets the specifications.
>Happens during development (before actual execution).
>Focuses on documents, design, code, and plans.
>It is a static process (no running of code).

Examples:
>Reviews
>Walkthroughs
>Inspections
>Checking SRS or Design Documents

ðŸ§ª Validation
>Checks whether the software meets the user's needs.
>Happens after development (post-coding).
>Focuses on actual product and user requirements.
>It is a dynamic process (involves execution of code).

Examples:
>Functional Testing
>System Testing
>User Acceptance Testing (UAT)
---------------------------------------------------------------------------------------

lesson 2 s/w requirement specification (srs)
----------------------------------------------------------------------------------------

ðŸŒ¾requirement analysis

>what is to be build
>requirement are uncover
>requirement changes
>tight project schedule
>communication  barrirer

phases:
1.	req elicitatiom
2.	req analysis
3.	req documentation
4.	req review


ðŸ¶ delphi technique
exchange paper piece of paper for revised requiements

---------------------------------------------------------------------------------------
ðŸ¶s/w quality assurance :process ensuring s/w product meet quality standards and requirements

>objective : prevent defect /improve qulity / ensure customer satisfaction
>technique : code review /audit 
>standard: iso 9000 / ieee 730 /cmmi
>continous improvement 
>metrices 
>training
>documentation

ðŸ¶validation/black box
>ensure s/w product meet end user requirements.
>are we building right prouct ?

ðŸ¶verification / white box
>ensure s/w product designed and developed according standard
>are we building product right ?

ðŸ¶cmm
>for improving s/w process to generate quality s/w:
>business phase:
â¦	initial
â¦	managed /repetable
â¦	defined
â¦	quantitively managed
â¦	optmizing
--------------------------------------------------------------------------------------------------

ðŸ’–lesson 03 s/w designing
--------------------------------------------------------------------------------------------------
ðŸ¶design
>input <srs> output <sdd>
>sdd contain all points in srs

---------------------------------------------------------------------------------------------------

ðŸ¶The COCOMO Model (Constructive Cost Model) is a software cost estimation model developed by Barry Boehm. It helps estimate:
â¦	Effort (in person-months),
â¦	Development time (in months),
â¦	Cost of a software project.

1. Effort (E) in person-months:E=aÃ—(KLOC)^b
2. Development Time (D) in months=D=cÃ—(E)^d
3. People Required (P) = P=E/D
--------------data-------------------------
E = Effort required (in person-months)
KLOC = Thousands of Lines of Code
a, b = Constants based on the project type
D = Development time (in months)
E = Effort calculated above
c, d = Constants based on the project type
P = Average number of persons required
E = Effort (person-months)
D = Development time (months)
----------------------------------------------------------------------------------------
ðŸ¶ unit 4 s/w testing
----------------------------------------------------------------------------------------
> because of human error there will be bug or fault
- errror = human action -- detected during dev
- bug = problem in a software -- dected during testing

>unit testing - testing indivual component in isolation
>integration testing- modules are combined and testing as a group
>system testing - complete and integrated s/w system as a whole is tested with specified srs.
> user acceptance testing - final testing phase before deployment check works in real world
> regression testing - ensure that previously developed and tested s/w work well after making changes / updates / bug fixes
>black box approach= check system as a whole
>white box approach = consered on process
>alpha testing = testing done on developer side
>beta testing = testing done on real life
>boundry value analysis
>equivalance partioning//black box technique

------------------------------------------------------------------------------------------












































