lesson one introduction
------------------------------------------------------------------------------------
program > steps to perform task /set of instruction

software > program along with documentation

s/w = program + documentation

s/w component = program + document + operating procedure

s/w crises = overrun development cost + exceed development time + quality not achived

s/w engineering = systematic application of engineering principle and methods to design , development , 		  testing and maintainance of s/w products.
-------------------------------------------------------------------------------------
üåæcharacteristics of s/w =
>developed through s/w process
>no physical wear and tear
>custom built in feature
>intangible / cannot be touch

üåæmajor problem in s/w development
>inadequate req gathering 
>lack of communication between stackholder
>poor project managment 
>lack of risk mitigation
>wrong technology selection
>insufficent time and money
>lack of skill set 
>less failure rate over time

üåæs/w quality attribute
>correctness
>usablity
>reliablity
>efficiency
>maintanibility
>portable
>scalability
>security

üåæs/w process :set of releted activities lead to production of s/w
>feasability study
>requirement analysis and specification(srs)
>designing(sdd)
>coding
>testing
>implementation
>mantainalibity

üåæs/w development life cycle : procedure follow during development of s/w product in well defined and managed way

---------------------------------------------------------------------------------------

üê∂ waterfall model
>inspired by manufacturing and construction process
>each step relies on a previous one
>simplest >linear >sequntial model
>one way cannot be go return
>used for small and medium sized project
>well defined and crystal clear requirment are required
>classical model 

steps:
1.	feasibility study
2.	req analysis
3.	design
4.	coding
5.	testing
6.	mainaince

---------------------------------------------------------------------------------------

üê∂ prototype model
>iterative approach
>refine through customer feedback
>repetative till satisfaction
>twotype a) evoluionary b)thrwoaway
>scope for accomodate new requireents

steps:
1.	req gathring
------------------
2.	quick design
3.	build prototype
4.	cstomer evalution
5.	refine requirements
-----repet---------
6.	design
7.	implement
8.	test
9.	maintain

--------------------------------------------------------------------------------------

üê∂ spiral model == risk factor introduce

phase 1: objective determination
phase 2: identify and resolve risk
phase 3: development and test
pahse 4: plan next iteration till satisfaction

>provide early and frequent customer feedback 
>resolve all possible risks
>alllow incermaental release and testing
>not for small project
> risk analyse need experties

---------------------------------------------------------------------------------------

üê∂incermental model

>development of initial implementation -> expose to user feedback -> evolve through several version
>make working s/w at early phase
>easier to test and debug during small iterations
>agile development
>continous improvement
>begin with basic version minimum functionality
>user feedback to make improvements


-----------------------------------------------------------------------------------------
üê± V-Model == verification + validation in parallel
Phase 1: Requirement Analysis
Phase 2: System Design
Phase 3: Architecture Design
Phase 4: Module Design
Phase 5: Coding
Phase 6: Unit Testing
Phase 7: Integration Testing
Phase 8: System Testing
Phase 9: Acceptance Testing

>testing starts from beginning (parallel to development)
>strong discipline and documentation
>suitable for small to medium-size projects
>no overlap in phases ‚Äì rigid structure
>not flexible for changing requirements
>bugs found early due to planned testing
--------------------------------------------------------------------------------------
üê∞ Agile Model == fast delivery + continuous feedback
Phase 1: Gather minimal requirements (user stories)
Phase 2: Plan iteration (sprint planning)
Phase 3: Design, Develop, Test within sprint
Phase 4: Deliver working product (increment)
Phase 5: Review & get feedback
Phase 6: Improve in next sprint (loop to Phase 2)

>customer involved in every step
>highly flexible for changes
>short iterations (1‚Äì4 weeks)
>better team collaboration
>early working software delivery
>requires active client participation
>not ideal for critical systems (banking, aviation, etc.)
--------------------------------------------------------------------------------------
üåæverification : 

>Checks whether the software meets the specifications.
>Happens during development (before actual execution).
>Focuses on documents, design, code, and plans.
>It is a static process (no running of code).

Examples:
>Reviews
>Walkthroughs
>Inspections
>Checking SRS or Design Documents

üß™ Validation
>Checks whether the software meets the user's needs.
>Happens after development (post-coding).
>Focuses on actual product and user requirements.
>It is a dynamic process (involves execution of code).

Examples:
>Functional Testing
>System Testing
>User Acceptance Testing (UAT)
---------------------------------------------------------------------------------------

lesson 2 s/w requirement specification (srs)
----------------------------------------------------------------------------------------

üåærequirement analysis

>what is to be build
>requirement are uncover
>requirement changes
>tight project schedule
>communication  barrirer

phases:
1.	req elicitatiom
2.	req analysis
3.	req documentation
4.	req review


üê∂ delphi technique
exchange paper piece of paper for revised requiements

---------------------------------------------------------------------------------------
üê∂s/w quality assurance :process ensuring s/w product meet quality standards and requirements

>objective : prevent defect /improve qulity / ensure customer satisfaction
>technique : code review /audit 
>standard: iso 9000 / ieee 730 /cmmi
>continous improvement 
>metrices 
>training
>documentation

üê∂validation/black box
>ensure s/w product meet end user requirements.
>are we building right prouct ?

üê∂verification / white box
>ensure s/w product designed and developed according standard
>are we building product right ?

üê∂cmm
>for improving s/w process to generate quality s/w:
>business phase:
‚¶Å	initial
‚¶Å	managed /repetable
‚¶Å	defined
‚¶Å	quantitively managed
‚¶Å	optmizing
--------------------------------------------------------------------------------------------------

üíñlesson 03 s/w designing
--------------------------------------------------------------------------------------------------
üê∂design
>input <srs> output <sdd>
>sdd contain all points in srs

---------------------------------------------------------------------------------------------------

üê∂The COCOMO Model (Constructive Cost Model) is a software cost estimation model developed by Barry Boehm. It helps estimate:
‚¶Å	Effort (in person-months),
‚¶Å	Development time (in months),
‚¶Å	Cost of a software project.

1. Effort (E) in person-months:E=a√ó(KLOC)^b
2. Development Time (D) in months=D=c√ó(E)^d
3. People Required (P) = P=E/D
--------------data-------------------------
E = Effort required (in person-months)
KLOC = Thousands of Lines of Code
a, b = Constants based on the project type
D = Development time (in months)
E = Effort calculated above
c, d = Constants based on the project type
P = Average number of persons required
E = Effort (person-months)
D = Development time (months)
--------------------------------------------------------------------------------------------------







































